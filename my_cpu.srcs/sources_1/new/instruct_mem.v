`timescale 1ns / 1ps
//////////////////////////////////////////////////////////////////////////////////
// Company: 
// Engineer: 
// 
// Create Date: 2025/08/16 10:36:44
// Design Name: 
// Module Name: instruct_mem
// Project Name: 
// Target Devices: 
// Tool Versions: 
// Description: 
// 
// Dependencies: 
// 
// Revision:
// Revision 0.01 - File Created
// Additional Comments:
// 
//////////////////////////////////////////////////////////////////////////////////


module instruct_mem(
    input [31:0] instruct_addr, //指令地址
    output [31:0] instruct_data //读取到的指令
);

reg [31:0] IM [0:1023]; //1024个指令存放在指令存储器
integer i;

 initial begin
           // 手动写几条指令，或者从文件加载
        IM[0] = 32'h20010005;  // addi $1,$0,5
        IM[1] = 32'h20020003;  // addi $2,$0,3
        IM[2] = 32'h00221820;  // add  $3,$1,$2
        IM[3] = 32'hac030000;  // sw   $3,0($0)
        IM[4] = 32'h8c040000;  // lw   $4,0($0)
        
         // BEQ 示例：如果 $1==$2，跳转到 IM[7] (偏移=2，注意 MIPS 偏移单位是指令数)
        IM[5] = 32'h10220002;  // beq $1,$2, label  (label在IM[8])

        // BNE 示例：如果 $1!=$2，跳转到 IM[8] (偏移=2)
        IM[6] = 32'h14220001;  // bne $1,$2, label2 (label2在IM[8])
        
        
        // ADDI 示例，用于修改寄存器
        IM[7] = 32'h20050001;  // addi $5,$0,1

        // J 指令示例：跳转到 IM[10]
        IM[8] = 32'h0800000a;  // j 10  (地址=10<<2)

        // NOP 或其他操作
        IM[9] = 32'h00000000;  // nop
        IM[10] = 32'h20060002; // addi $6,$0,2
         // ===== JAL 指令 =====
        IM[11] = 32'h0c00000e;  // jal 14 (地址=14<<2)，$31=PC+4=IM[12]
        IM[12] = 32'h00000000;  // nop
        IM[13] = 32'h20070007;  // addi $7,$0,7   (应跳过)

        // JAL 跳转目标
        IM[14] = 32'h20080008;  // addi $8,$0,8   $8=8

        // ===== JR 指令 =====
        //IM[15] = 32'h03e00008;  // jr $31 -> 跳回 IM[16]

        IM[15] = 32'h20090009;  // addi $9,$0,9   $9=9
        
                // ===== 逻辑与移位类指令 =====

        IM[16] = 32'h2001000F;  // addi $1,$0,15   ; $1=0xF
        IM[17] = 32'h200200F0;  // addi $2,$0,240  ; $2=0xF0

        // AND
        IM[18] = 32'h00222824;  // and  $5,$1,$2   ; $5 = $1 & $2 = 0x00

        // OR
        IM[19] = 32'h00223025;  // or   $6,$1,$2   ; $6 = $1 | $2 = 0xFF

        // XOR
        IM[20] = 32'h00223826;  // xor  $7,$1,$2   ; $7 = $1 ^ $2 = 0xFF
        
        //IM[21] = 32'b0;
        // NOR
        IM[21] = 32'h00224027;  // nor  $8,$1,$2   ; $8 = ~($1 | $2)

        // SLL (逻辑左移)
        IM[22] = 32'h00024880;  // sll  $9,$2,2    ; $9 = $2 << 2 = 0x3C0

        // SRL (逻辑右移)
        IM[23] = 32'h00025042;  // srl  $10,$2,1   ; $10 = $2 >> 1 = 0x78

        // SRA (算术右移, 保持符号)
        IM[24] = 32'h00025043;  // sra  $10,$2,1   ; $10 = $2 >>> 1 (算术)

        IM[25] = 32'h3c081234; //lui $8, 0x1234
        
        IM[26] = 32'h2822FFFB; //slti $!, $2, 65531
        
        IM[27] = 32'h00411804;  //sllv $3, $1, $2
        
        IM[28] = 32'h03e00008;  // jr $31 -> 跳回 IM[16]
        
        //IM[28] = 32'h01011022; //sub $8, $1, $2
        
        //IM[29] = 32'h3905FFFF; //xori
        
        //IM[30] = 32'h2D05000A; //sltiu

        //IM[31] = 32'h03e00008;  // jr $31 -> 跳回 IM[16]
                
        //单独测试逻辑运算和移位指令
            // ==== 逻辑运算 ====
    /*IM[0] = 32'h2001000f;  // addi $1,$0,15   ($1 = 0x0000000F)
    IM[1] = 32'h200200f0;  // addi $2,$0,240  ($2 = 0x000000F0)

    IM[2] = 32'h00221824;  // and  $3,$1,$2   ($3 = $1 & $2 = 0x00)
    IM[3] = 32'h00221825;  // or   $3,$1,$2   ($3 = $1 | $2 = 0xFF)
    IM[4] = 32'h00221826;  // xor  $3,$1,$2   ($3 = $1 ^ $2 = 0xFF)
    IM[5] = 32'h00221827;  // nor  $3,$1,$2   ($3 = ~($1 | $2))

    // ==== 移位指令 ====
    IM[6] = 32'h00011080;  // sll  $2,$1,2   ($2 = $1 << 2)
    IM[7] = 32'h00021882;  // srl  $3,$2,2   ($3 = $2 >> 2)
    IM[8] = 32'h00021883;  // sra  $3,$2,2   ($3 = $2 >>> 2 算术右移)

    // nop (占位)
    IM[9]  = 32'h00000000;
    IM[10] = 32'h00000000;*/

        
        
        
        //单独测试jr指令
        // 1. 初始化指令存储器
    // =====================
        // addi $31, $0, 20   // $31 = 20 (作为返回地址)
        /*IM[0] = 32'h201f0014;  
    
        // jr $31   // PC <- $31
        IM[1] = 32'h03e00008;  
    
        // addi $9, $0, 9  // 如果 JR 正常，应该跳到 IM[20]，不会执行这里
        IM[2] = 32'h20090009;  

    // 填充 NOP
        for (i = 3; i < 19; i = i + 1)
            IM[i] = 32'b0;
            
       // 目标位置 (PC=20，对应 IM[20])
        IM[20] = 32'h200a000a;  // addi $10,$0,10  // $10=10, 说明 JR 生效

        

        // 目标位置 (PC=20，对应 IM[20])
         //IM[20] = 32'h200a000a;  // addi $10,$0,10  // $10=10, 说明 JR 生效*/

        
        
        
        
        // 其余的清零
        
        //for (i = 17; i < 256; i = i + 1)
            //IM[i] = 32'b0;
            
end

assign instruct_data = IM[instruct_addr[11:2]]; //选出1024条条指令的索引，低2位一直是00，没有用

endmodule
